---
title: Implementation and Testing Deep Dive
pagetitle: Implementation and Testing Deep Dive
theme: resources
section: Resources

---

<div class="container pt-5" data-bs-spy="scroll" data-bs-target="#playbook_menu" data-bs-offset="0">
  <div class="row">
    <div class="col-md-3">
      <%= partial "partials/tech_standards_menu" %>  
    </div>
  
    <div id="content"  class="col-md-9">
      <h1>Deep Dive into Implementation and Testing</h1>
      <p>
        The goal of implementation and testing is to ensure that the developed IG (Implementation Guide) can be translated into real-world software and that this software provides value to end users. To achieve this, the IG developers often need to develop open-source demonstration software, a reference implementation, and should develop testing tools to support software adoption. These resources will help speed the implementation process, guide developers in adapting the software to real-world instances, and excite end users about the potential benefits of the community’s use case.      
	  </p>
      <p>
        Here, we will walk through the development processes identifying common, readily available, free tools that can be used to manage, test, and update the community’s software.      
	  </p>
	  <h2>Sofware Development Lifecycle (SDLC)</h2>
	  <p>
        The SDLC guides software through key steps in the development process:
      </p>
      <ul>
         <li>
          Requirement gathering 
         </li>
         <li>
          Software Design
         </li>
         <li>
          Coding
         </li>
		 <li>
		  Testing
		 </li>
		 <li>
		  Deployment
		 </li>
		 <li>
		  Maintenance and Support
		 </li>
      </ul>
	  <p>
	   While software vendors will oversee this process when they adapt the community’s IG for their software, the community will need to follow this process for any open-source software that is released, such as the reference implementation or testing tools. This discussion provides a detailed overview of the process and methodologies (waterfall, agile, and others) used to guide software development teams through the SDLC phases.
	  </p>
	  <h2>Development Recommendations</h2>
	  <h3>Requirements Gathering</h3>
	  <p>
	   See the <%= link_to("Use Cases & Planning", "/playbook/use_cases_planning.html") %> page for guidance on requirement gathering.
	  </p>
      <h3>Software Design<h3>
	  <p>	
		See the <%= link_to("Standards Development", "/playbook/standards_development.html") %> section and the associated <%= link_to("Standards Development Deep Dive", "/playbook/resources/tech-standards.html") %> for guidance on IG development and software design.
	  </p>
	  <h3>Coding</h3>
	  <h4>Development Environment</h4>
	  <p>
	    It is strongly recommended that a community’s open-source software be developed within an environment that allows a teams of developers to effectively manage the code. Key personnel like developers can and often do change over the course of the project, as a result it is critical that there is a single repository for the community’s code, ideally one that can be made public when software is ready to be shared. There are many options for code management and software repositories, the most commonly used repository for open-source projects is <a href="https://github.com/">GitHub</a>. It is also recommended that the developers use project management software such as Jira or Microsoft Teams. This helps ensure that development goals and bug fixes are tracked and resolved in a timely manner.
	  </p>
	  <h4>FHIR Artifacts</h4>
	  <p>
	    A common starting point for many looking to jumpstart their development are existing FHIR software artifacts such as the <a href="https://hapifhir.io/">Hapi FHIR software</a>, which provides working JAVA software for many basic FHIR resources. Hapi FHIR, <a href="https://confluence.hl7.org/display/FHIR/Open+Source+Implementations">HL7's Confluence page</a>, and other FHIR open-source responsitories provide basic FHIR software that can be adapted for the community’s purposes.
	  </p>
	  <h3>Testing</h3>
	  <p>
	   Software testing can be broken down into three software states as described in the <%= link_to("Implementation & Testing", "/playbook/implementation.html") %> section: 
	  </p>
	  <ul>
         <li>
          Alpha testing - Initial development and testing stage conducted by developers
         </li>
         <li>
          Beta testing – second round testing conducted with willing potential end users
         </li>
         <li>
          Real-world implementation – implementation and testing of instances of software within live software systems using real-world workflows and data
         </li>
      </ul>
      <p>
       For community developed tools, the first two states are the primary focus of community software development. Since the final state, real-world implementations, will rely on the community to partnering with software vendors or healthcare organizations to implement instances of the software withing local systems. Discussions will focus on alpha and beta state testing and leave real-world implementations decisions to software vendors.
      </p>
	  <h4>Alpha Testing</h4>
      <p>
        Much of the development and testing strategy will rely on developers coordinating with use case subject matter experts. One critical need in this stage of testing is for accurate synthetic or fake patients to test workflows. To avoid the time-consuming, monotonous process of manually creating test patients, a synthetic patient data software should be used. The most widely used software within open-source medical development communities, at Connectathons, and in private industry is Synthea because it can generate populations of realistic patients with medical data such as medications, allergies, conditions, and clinical notes. For more information on Synthea’s current capabilities and instructions for generating patient data see <a href="https://synthetichealth.github.io/synthea/">Synthea’s GitHub</a> page for more details.      
	  </p>
	  <h4>Beta Testing</h4>
	  <p>
        To both guide community members in their individual implementations and provide functionality to demonstrated and test to use case end users, it is recommended that the community develop an open-source demo of their IG, a reference implementation. A reference implementation is a system agnostic implementation of an IG that serves as an idealized representation of how the data exchange should function. Often it is a simple client-server data exchange with a few use case examples to demonstrate software functionality and utility. Reference implementations are often used to test and get feedback from both developers and end users IGs in dedicated implementation feedback sessions and in more general Connectathons.
      </p>
      <p>
	    In this stage of development it is also helpful to investigate developing testing tools for the community. Properly developed, IG testing tools can facilitate uniform adoption of the community’s IGs and simplify individual implementations by helping developers identify issues with their software. One tool that can be adapted to test the community’s IG is the <a href="https://inferno-framework.github.io/docs/">Inferno testing toolkit</a>, which is widely used within the FHIR community to test numerous IGs, and by the Assistant Secretary for Technology Policy / Office of the National Coordinator (ASTP/ONC) to verify EHRs meet certification requirements for interoperability. 
	  </p>
	  <h4>Real-world Testing</h4>
	  <p>
	    There is an overlap between real-world testing and deployment as real-world testing actually deploys software to local systems. The goal of this stage is to verify the efficacy and efficiency of the community's software, identify any lingering issues with IG development, and gather feedback and prepare the community for larger scale implementations. This step is largely overseen by software vendors who are best equipped to make implementation and testing decisions within their software systems. 
	  </p>
	  <h3>Deployment</h3>
	  <p>
	    See the <%= link_to("Adoption", "https://mitre.github.io/playbook/playbook/adoption.html#adoption") %> subsection of Adoption & Value for high-level guidance on promoting adoption of software.
	  </p>
	  <h3>Maintenance and Support</h3>
	  <h4>Software Versioning</h4>
      <p>
        There is one constant in life, change. FHIR, its underlying standards, security protocols, and the community’s IG will all have regular updates, some of which introduce major changes, to ensure continual improvement and refinement of data exchange processes. When creating software development plans, it is a necessity to have a well-established version control process within GitHub or whatever code repository management software the community chooses to use. See this <a href="https://github.com/resources/articles/software-development/what-is-version-control">article</a> for specific recommendation and guidance on maintaining version control for the community’s software releases.        
	  </p>


          
    </div>
  </div>
</div>
